<?php
/**
 * @file
 * Farm area generate module.
 */

/**
 * Generate geometries within a polygon at a given orientation.
 *
 * @param $polygon
 *   A Polygon geometry object that represents the parent area. Child area
 *   geometries will be generated within this polygon.
 * @param $count
 *   The number of child geometries to generate.
 * @param $orientation
 *   The orientation of child geometries, in degrees. This should be a positive
 *   integer between 0 and 359.
 *
 * @return array
 *   Returns an array of child geometries.
 */
function farm_area_generate_geometries($polygon, $count, $orientation = 0) {

  // If the orientation isn't within an acceptable range, bail.
  if ($orientation < 0 || $orientation > 359) {
    return array();
  }

  // Rotate the polygon around its centroid so that the orientation is 0.
  $origin = $polygon->centroid();
  $angle = 359 - $orientation;
  $rotated_polygon = farm_area_generate_rotate_polygon($polygon, $origin, $angle);

  // Calculate the bounding box of the rotated polygon.
  $bbox = $rotated_polygon->getBBox();

  // Generate horizontal rectangles that fill the bounding box.
  $geometries = farm_area_generate_bbox_geometries($bbox, $count);

  // Rotate child geometries back to the original orientation and trim to fit
  // the original polygon.
  $final_geometries = array();
  foreach ($geometries as $geometry) {
    $rotated = farm_area_generate_rotate_polygon($geometry, $origin, $orientation);
    $trimmed = $rotated->intersection($polygon);
    $final_geometries[] = $trimmed;
  }

  return $final_geometries;
}

/**
 * Generates a set of rectangle geometries running horizontally to fill a
 * bounding box.
 *
 * @param array $bbox
 *   An array containing bounding box information (in the same format that
 *   GeoPHP generates).
 * @param int $count
 *   The number of rectangles to fit into the box.
 *
 * @return array
 *   Returns an array of rectangle geometries that fit into the bounding box.
 */
function farm_area_generate_bbox_geometries($bbox, $count) {

  // Load GeoPHP.
  geophp_load();

  // Calculate how wide each rectangle needs to be.
  if (geoPHP::bcmathInstalled()) {
    $total_width = bcsub($bbox['maxy'], $bbox['miny']);
    $geom_width = bcdiv($total_width, $count);
  }
  else{
    $total_width = $bbox['maxy'] - $bbox['miny'];
    $geom_width = $total_width / $count;
  }

  // Fill the bounding box with rectangles.
  $geometries = array();
  $starting_point = new Point($bbox['minx'], $bbox['maxy']);
  for ($i=1;$i<=$count;$i++) {
    $points = array();
    $points[] = $starting_point;
    if (geoPHP::bcmathInstalled()) {
      $points[] = new Point($bbox['maxx'], bcsub($bbox['maxy'], bcmul($geom_width, ($i - 1))));
      $points[] = new Point($bbox['maxx'], bcsub($bbox['maxy'], bcmul($geom_width, $i)));
      $points[] = new Point($bbox['minx'], bcsub($bbox['maxy'], bcmul($geom_width, $i)));
    }
    else {
      $points[] = new Point($bbox['maxx'], $bbox['maxy'] - ($geom_width * ($i - 1)));
      $points[] = new Point($bbox['maxx'], $bbox['maxy'] - ($geom_width * $i));
      $points[] = new Point($bbox['minx'], $bbox['maxy'] - ($geom_width * $i));
    }
    $points[] = $starting_point;
    $geometries[] = new Polygon(array(new LineString($points)));
    $starting_point = $points[3];
  }

  // Return the geometries.
  return $geometries;
}

/**
 * Rotate a polygon around an origin.
 *
 * @param $polygon
 *   A Polygon geometry object.
 * @param $origin
 *   An origin point to rotate around.
 * @param $angle
 *   The angle of rotation, in degrees.
 *
 * @return \Polygon
 *   Returns a Polygon geometry object that has been rotated around an origin.
 */
function farm_area_generate_rotate_polygon($polygon, $origin, $angle) {

  // Load GeoPHP.
  geophp_load();

  // If the geometry is not a polygon, bail.
  if ($polygon->geometryType() != 'Polygon' || $polygon->components[0]->geometryType() != 'LineString') {
    return $polygon;
  }

  // Iterate through the polygon's points, and rotate each around the origin.
  $linestring = $polygon->components[0];
  $new_points = array();
  if (!empty($linestring->components)) {
    foreach ($linestring->components as $point) {
      $new_points[] = farm_area_generate_rotate_point($point, $origin, $angle);
    }
  }

  // Return a new Polygon object.
  return new Polygon(array(new LineString($new_points)));
}

/**
 * Rotate a point around an origin.
 *
 * @param $point
 *   A Point geometry object.
 * @param $origin
 *   An origin point to rotate around.
 * @param $angle
 *   The angle of rotation, in degrees.
 *
 * @return \Point
 *   Returns a Point geometry object that has been rotated around an origin.
 */
function farm_area_generate_rotate_point($point, $origin, $angle) {

  // Load GeoPHP.
  geophp_load();

  // If $point and $origin are not points, or $angle is not an integer between
  // 0 and 359, bail.
  if ($point->geometryType() != 'Point' || $origin->geometryType() != 'Point' || $angle < 0 || $angle > 359) {
    return $point;
  }

  // Convert the angle to radians.
  $angle = deg2rad($angle);

  // Calculate the new rotated points.
  if (geoPHP::bcmathInstalled()) {
    $x = bcadd($origin->x(), bcsub(bcmul(bcsub($point->x(), $origin->x()), cos($angle)), bcmul(bcsub($point->y(), $origin->y()), sin($angle))));
    $y = bcadd($origin->y(), bcadd(bcmul(bcsub($point->x(), $origin->x()), sin($angle)), bcmul(bcsub($point->y(), $origin->y()), cos($angle))));
  }
  else {
    $x = $origin->x() + (($point->x() - $origin->x()) * cos($angle)) - (($point->y() - $origin->y()) * sin($angle));
    $y = $origin->y() + (($point->x() - $origin->x()) * sin($angle)) + (($point->y() - $origin->y()) * cos($angle));
  }

  // Return a new Point object.
  return new Point($x, $y);
}
