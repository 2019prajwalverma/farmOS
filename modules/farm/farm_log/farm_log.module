<?php
/**
 * @file
 * Code for the Farm Log feature.
 */

// Include Features code.
include_once 'farm_log.features.inc';

/**
 * Implements hook_form_alter().
 */
function farm_log_form_alter(&$form, &$form_state, $form_id) {

  // If this is a log form, attempt to prepopulate entityreference fields.
  if ($form_id == 'log_form') {
    farm_log_prepopulate_log_form_references($form);
  }
}

/**
 * Implements hook_entity_presave().
 */
function farm_log_entity_presave($entity, $type) {

  // When a log entity is being saved, populate the geometry field from areas.
  if ($type == 'log') {
    farm_log_populate_geometry($entity);
  }
}

/**
 * Helper function for creating log categories. Terms will only be added if
 * they don't already exist.
 *
 * @param array $categories
 *   An array of strings that will be added as terms to the Farm Log Categories
 *   vocabulary.
 */
function farm_log_categories_create($categories) {

  // If the categories is not an array, bail.
  if (!is_array($categories)) {
    return;
  }

  // Define the vocabulary machine name.
  $vocabulary_machine_name = 'farm_log_categories';

  // Load the vocabulary.
  $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_machine_name);

  // If the vocabulary doesn't exist, bail.
  if (empty($vocabulary->vid)) {
    return;
  }

  // Iterate through the categories.
  foreach ($categories as $category) {

    // First, check to see if the term already exists. If it does, skip it.
    $terms = taxonomy_get_term_by_name($category, $vocabulary_machine_name);
    if (!empty($terms)) {
      continue;
    }

    // Translate the category name.
    $term_name = t($category);

    // Create the new term.
    $term = new stdClass();
    $term->name = $term_name;
    $term->vid = $vocabulary->vid;
    taxonomy_term_save($term);
  }

  // Always reset the categories to alphabetical order.
  /**
   * @see taxonomy_vocabulary_confirm_reset_alphabetical_submit()
   */
  db_update('taxonomy_term_data')
    ->fields(array('weight' => 0))
    ->condition('vid', $vocabulary->vid)
    ->execute();
}

/**
 * Create log categories on behalf of all modules that provide them.
 */
function farm_log_categories_create_all() {
  $categories = module_invoke_all('farm_log_categories');
  if (!empty($categories)) {
    farm_log_categories_create($categories);
  }
}

/**
 * Helper function for populating a log's geometry from an area reference field.
 *
 * @param Entity $entity
 *   The entity to act upon.
 *
 * @see farm_log_entity_movement_presave().
 */
function farm_log_populate_geometry($entity) {

  // Define the area field name.
  $area_field = 'field_farm_area';

  // If the log doesn't have an area reference field, bail.
  if (!isset($entity->{$area_field})) {
    return;
  }

  // If a geometry is already defined, bail.
  if (!empty($entity->field_farm_geofield[LANGUAGE_NONE][0]['geom'])) {
    return;
  }

  // Load the area(s) referenced by the area reference field.
  $area_ids = array();
  if (!empty($entity->{$area_field}[LANGUAGE_NONE])) {
    foreach ($entity->{$area_field}[LANGUAGE_NONE] as $area_reference) {
      if (!empty($area_reference['tid'])) {
        $area_ids[] = $area_reference['tid'];
      }
    }
  }

  // Extract geometries from the areas.
  $geoms = farm_area_extract_geoms($area_ids);

  // Populate the geofield.
  farm_map_geofield_populate($entity, $geoms);
}

/**
 * Helper function for populating entity reference fields in log forms.
 *
 * @param array $form
 *   The form array to modify, passed by reference.
 */
function farm_log_prepopulate_log_form_references(&$form) {

  // Define the fields we will be populating.
  $fields = array(
    'field_farm_asset' => array(
      'entity_type' => 'farm_asset',
      'url_param' => 'farm_asset',
    ),
    'field_farm_area' => array(
      'entity_type' => 'taxonomy_term',
      'url_param' => 'farm_area',
    ),
    'field_farm_log_owner' => array(
      'entity_type' => 'user',
    ),
  );

  // Populate the fields.
  foreach ($fields as $field => $info) {

    // Start with an empty array of IDs.
    $ids = array();

    // If the field does not exist on the log, skip it.
    if (!isset($form[$field])) {
      continue;
    }

    // If a URL param is available, get a list of entity IDs from it.
    if (!empty($info['url_param'])) {
      $ids = farm_log_ids_from_url($info['url_param']);
    }

    // Or, if the entity type is 'user', load the ID from the current user.
    elseif ($info['entity_type'] == 'user') {
      global $user;
      if (!empty($user->uid)) {
        $ids[] = $user->uid;
      }
    }

    // If there are no IDs, skip.
    if (empty($ids)) {
      continue;
    }

    // Prepopulate with our helper function.
    farm_log_prepopulate_entityreference($form, $info['entity_type'], $field, $ids);
  }
}

/**
 * Helper function for pre-populating entityreference form elements.
 *
 * @param array $form
 *   The form array to modify, passed by reference.
 * @param string $entity_type
 *   The entity type that is being referenced.
 * @param string $field_name
 *   The machine name of the entity reference field.
 * @param array $entity_ids
 *   An array of entities to add to the references.
 */
function farm_log_prepopulate_entityreference(&$form, $entity_type, $field_name, $entity_ids) {

  // Load the field instance definition.
  $form_entity_type = $form['#entity_type'];
  $form_entity_bundle = $form['#bundle'];
  $field_instance = field_info_instance($form_entity_type, $field_name, $form_entity_bundle);

  // Validate the entity IDs by loading them. Rebuild the list of IDs using
  // only the entities that loaded.
  $entities = entity_load($entity_type, $entity_ids);
  $entity_ids = array();
  foreach ($entities as $entity) {
    $entity_ids[] = entity_id($entity_type, $entity);
  }

  // If there are no entity IDs, bail.
  if (empty($entity_ids)) {
    return;
  }

  // If the widget type is "radios/checkboxes" or "select list"...
  if (in_array($field_instance['widget']['type'], array('options_buttons', 'options_select'))) {

    // Use the array of IDs as the field's default value.
    if (empty($form[$field_name][LANGUAGE_NONE]['#default_value'])) {
      $form[$field_name][LANGUAGE_NONE]['#default_value'] = $entity_ids;
    }
  }

  // If the widget type is "autocomplete" or "autocomplete tags"...
  elseif (in_array($field_instance['widget']['type'], array('entityreference_autocomplete', 'entityreference_autocomplete_tags'))) {

    // Build a list of entity labels in the format that the widget expects.
    $labels = array();
    foreach ($entities as $id => $entity) {
      $labels[] = entity_label($entity_type, $entity) . ' (' . $id . ')';
    }

    // For "autocomplete", add each one as a separate field.
    if ($field_instance['widget']['type'] == 'entityreference_autocomplete') {
      foreach ($labels as $key => $label) {

        // If the item isn't empty, skip it.
        if (!empty($form[$field_name][LANGUAGE_NONE][$key]['target_id']['#default_value'])) {
          continue;
        }

        /**
         * @todo
         * This seems to be the easiest way to auto-populate entityreference_autocomplete
         * widgets, but it is MESSY! If anyone can figure out a better way, I will buy
         * you a beer.
         */
        // Copy the initial array structure from the first element.
        $form[$field_name][LANGUAGE_NONE][$key] = $form[$field_name][LANGUAGE_NONE][0];

        // Set the default, delta, and weight values.
        $form[$field_name][LANGUAGE_NONE][$key]['target_id']['#default_value'] = $label;
        $form[$field_name][LANGUAGE_NONE][$key]['target_id']['#delta'] = $key;
        $form[$field_name][LANGUAGE_NONE][$key]['target_id']['#weight'] = $key;

        // Only make the first one required.
        if ($key > 0) {
          $form[$field_name][LANGUAGE_NONE][$key]['target_id']['#required'] = 0;
        }

        $form[$field_name][LANGUAGE_NONE]['#max_delta'] = $key;
        $form[$field_name][LANGUAGE_NONE][$key]['_weight']['#delta'] = $key;
        $form[$field_name][LANGUAGE_NONE][$key]['_weight']['#default_value'] = $key;
      }
    }

    // For "autocomplete tags", implode them all into one comma-separated list.
    elseif ($field_instance['widget']['type'] == 'entityreference_autocomplete_tags') {
      if (empty($form[$field_name][LANGUAGE_NONE]['#default_value'])) {
        $form[$field_name][LANGUAGE_NONE]['#default_value'] = implode(', ', $labels);
      }
    }
  }

  // If the widget type is "entity reference view widget"...
  elseif ($field_instance['widget']['type'] == 'entityreference_view_widget') {

    // Add a set of checkbox form elements, as the entityreference_view_widget
    // module expects...
    foreach ($entities as $id => $entity) {

      // If the item isn't empty, skip it.
      if (!empty($form[$field_name][LANGUAGE_NONE][$id]['target_id'])) {
        continue;
      }

      // Add the checkbox element.
      $form[$field_name][LANGUAGE_NONE][$id]['target_id'] = array(
        '#type' => 'checkbox',
        '#return_value' => $id,
        '#value' => $id,
        '#title_display' => 'after',
        '#attributes' => array(
          'checked' => 'checked',
        ),
        '#title' => entity_label($entity_type, $entity),
      );
    }
  }
}

/**
 * Helper function for retrieving a list of entity IDs from a URL query param.
 *
 * @param string $param
 *   The URL query param to look at.
 *
 * @return array
 *   Returns an array of IDs.
 */
function farm_log_ids_from_url($param) {

  // If the GET parameter isn't set, bail.
  $params = drupal_get_query_parameters();
  if (empty($params[$param])) {
    return array();
  }

  // If only a single ID is passed, convert it to an array.
  if (!is_array($params[$param])) {
    $params[$param] = array($params[$param]);
  }

  // Return the array of IDs.
  return $params[$param];
}
